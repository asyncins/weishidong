---
title: 时序图 Squence
sidebar: 'auto'
date: 2020-07-21
tags:
 - 绘图指南

categories:
 - 实用技能
---

> 使用快捷键 Ctrl+D 或 Command+D 可快速收藏本技术专栏 收获爬虫架构/爬虫逆向/存储引擎/消息队列/Python/Golang相关知识



和用例图的上帝视角不同的是，时序图的视角是线性的，它关注的是对象之间交互的顺序和发生的时间。在设计程序或者系统时，我们必须清晰地了解对象与对象之间交互的先后顺序和时间线，时序图就是用来记录这些内容的。



## 时序图由哪些元素组成

### 基本组成元素

在时序图中，对象用矩形表示，每个对象都有一条向下延伸的虚线，这条虚线叫做对象的生命线。生命线上允许有多个垂直的矩形，它们表示当前对象的激活状态，意思是对象正在执行某个操作。矩垂直矩形的长度表示激活的持续时间，不要求精确表示时间。下图是时序图中主要组成元素的图示。

![ZPPTiR](https://img.weishidong.com/ZPPTiR.png)

左侧的箭头和文字只是为了说明，实际上时序图中并不包含这组元素。看到这里或许你会问，多个对象之间的交互，用什么方式或者图形元素来表示呢？

### 代表交互的消息线

在时序图中，一个对象到另一个对象的消息用跨越对象生命线的消息线表示。通常情况下，对象之间的交互会是调用关系，例如函数 A 调用函数 K，而函数 K 有可能会返回一个消息，这样的关系用实线实心箭头和虚线箭头表示。除此之外，还有另外一种特殊情况：异步。在异步调用场景中，消息发送对象将控制权转交给接收对象，不等待操作完成就返回，所以异步的消息线以实线箭头表示。具体符号和含义如下图所示。

![SAnXZ1](https://img.weishidong.com/SAnXZ1.png)

### 对象名称和注释

每个对象都有自己的名称，对象的名称由名称和对象组成，以冒号作为分隔，冒号左侧是名称右侧是对象。例如 Running:Object-C 中的 Running 是名称，Object-C 是对象，它们组合到一起就是对象的名称。要注意的是，时序图中允许存在匿名对象，即 :Object-A。

调用注释是为了描述对象之间消息线的作用或者调用的目的，例如从一条从对象 :Object-A 到 Running:Object-C 的消息线表示一个匿名对象调用名为 Running 的对象，假设调用时用到一个名为 Run 的函数，那么就以 Run() 作为消息线的调用注释。

在基本组成元素的基础上为对象添加消息线，并加上对象名称和调用注释，我们就得到了一个完整的时序图。要注意的是，对象发出的消息线可以由自己接收。一个简单的时序图如下图所示。

![MwIIsY](https://img.weishidong.com/MwIIsY.png)

::: danger

有些时序图的对象名称下面会带有下划线，例如 <u>Eat:Object-B</u>。其实这个可以根据习惯选择带或者不带，如果追求与 UML 规范一致，那是需要带下划线的。

:::

### 时序图的重要元素-时间

时序图名称的由来，是因为图围绕着时间和顺序展开。在时序图中，垂直方向代表时间维度，时间流逝的方向自顶向下。上方的交互发生时间要比下方的交互发生时间早。实际上时序图是二维的，即自左至右的对象顺序和自顶向下的时间顺序。如果要为上图标明执行顺序，那么我们将得到如下所示的时序图。

![image-20200719114955911](https://img.weishidong.com/image-20200719114955911.png)

::: tip

实际上时序图不需要特意标注执行序号，因为它本身就具备了时间顺序的特性。

:::



## 程序运行时创建对象

在 Python 语言中，我们可以让程序在运行期间创建一个新的对象实例，而且系统中确实也有这样的场景，那这种情况如何在时序图中表示呢？

基于上面的时序图，假设我们需要在 Eat:Object-B 执行期间创建一个 Drink 对象，可以像下图这样画。

![Kjmz7t](https://img.weishidong.com/Kjmz7t.png)

图中用不同的配色是为了方便大家阅读，实际上可以用相同的配色。创建新的对象时记得用关键字为 create 的构造型进行标注，方便看图的人理解。



## 销毁对象

既然有运行时创建对象，那么运行完毕后销毁对象的场景也是有的。对象的销毁用一个加粗的 **X** 表示，以关键字为 distroy 的构造型对销毁进行标注。X 通常置于生命线的末端，代表它的生命已经到了尽头，具体表达如下图所示。

![go6ada](https://img.weishidong.com/go6ada.png)

要注意的是，主动销毁和生命周期自然结束是不同的，带有加粗 **X** 的就是主动销毁，生命周期自然结束不需要特殊表示。

## 帧化-时序图的复用

::: warning

不得不说国外的程序员很擅长将各种各样的名词和概念融入到编程中。

:::

在 UML 规范中，用一个左上角带有间隔区的矩形框将时序图包裹起来就叫做时序图的帧化，左上角的间隔区用来填写帧的名称，具体如下图所示。

![image-20200719123051464](https://img.weishidong.com/image-20200719123051464.png)

除了将较完整的步骤帧化以外，还可以将某几个步骤进行帧化。在编程中，这就是函数封装、代码复用的操作，具体代码看起来像这样：

```python
def itoa(val)-> str:
    pass

def atoi(val)-> int:
    pass

def calculation(left, right)-> str:
    if not isinstance(left, int):
        left = atoi(left)
    if not isinstance(right, int):
        right = atoi(right)
    res = itoa((left + right) * left)
    return res
```

calculation 函数中调用了 itoa 函数和 atoi 函数，用于转换传入参数和计算结果的类型。atoi 和 itoa 中的处理有可能是多个步骤，但最终将它们封装成一个函数来进行调用，使得这段转换参数类型的逻辑变得可复用。用时序图中的帧化来表示的话，大概像下图这样。

![image-20200719130023374](https://img.weishidong.com/image-20200719130023374.png)

在左侧的 calculation 帧当中将原本用于转换字符类型的代码逻辑进行帧化，被帧化的部分叫做交互事件，用 ref 表示。从代码上可以理解为封装了两个函数。在左侧的时序图中可以复用其他地方帧化的交互事件，即直接把帧拿过来表示服用这部分逻辑或者处理方法。复用时帧的名称仍然保持 ref 不变，另外给交互事件取一个新名字来表示它的作用。

我觉得可以用序号来区分不同的交互事件，例如 ref1、ref2。

::: danger

时序图还有一种叫做交互片断的东西，实际上和交互事件相差并不大，感兴趣的朋友可以自行查阅资料，这里不再赘述。

:::



## 实战，用户注册时序图

学习的目的是为了将知识融入到工作当中，谓之学以致用。上面已经充分了解了时序图的组成和表达方式，接下来我们以 Web 应用用户注册为场景绘制一幅用户注册时序图。

首先整理需求并假设场景，用户注册通常包含填写信息、参数校验、确认等阶段。其中确认一般是短信验证码或者邮箱验证，这里设定为邮箱验证。由此可以绘制出如下所示的时序图基础结构。

![image-20200719132644157](https://img.weishidong.com/image-20200719132644157.png)

然后我们再来看看顺序，用户填写完资料后点击提交按钮，信息被送到后端，后端对用户提交的信息进行校验。校验通过后系统便会发送确认邮件，这一步是为了验证用户的有效性。在上图的基础上增加验证和邮件发送步骤，具体如下图所示。

![image-20200719133209502](https://img.weishidong.com/image-20200719133209502.png)

考虑到用户体验，服务端通常会选择异步发送邮件，同时返回一条类似“邮件已发送，请前往邮箱验证”的消息给用户，提醒用户去检查邮箱是否有新邮件。用户在邮箱中看到验证码，将验证码填写到页面中并再次提交，服务端收到用户提交的验证码后与数据库中存储的信息进行比对，最后返回类似“注册成功”的消息给用户，具体如下图所示。

![image-20200719133504111](https://img.weishidong.com/image-20200719133504111.png)

当然，如果想要更细致的话可以在时序图中加上数据库读写对象，让整个流程看起来更完整。绘图的时候要记得区分异步调用、调用和返回的箭头表示方式——实线、虚线、实心箭头。

以上就是整个时序图相关的知识介绍，让我们进入到下一个知识点吧！