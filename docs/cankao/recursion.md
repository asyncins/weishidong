---
title: 递归算法的原理与代码实现
sidebar: 'auto'
date: 2021-03-12
tags:
- Python 编程参考
- 算法

categories:
 - 编程参考
---

> 使用快捷键 Ctrl+D 或 Command+D 可快速收藏本技术专栏 收获爬虫架构/爬虫逆向/存储引擎/消息队列/Python/Golang相关知识



递归的英文写作 Recursion，递归算法中的递归指的是在函数的定义中调用函数自身的方法。递归算法是一种实现重复操作的不二选择，它有以下几个特点：


- [ ] 函数调用自身；
- [ ] 循环往复地执行；
- [ ] 有确定的跳出条件，这个条件称为递归出口；



## 初识递归算法


单纯看文字描述不太容易理解，我们可以借助图来帮我我们理解递归中的无限循环调用自身适用于什么场景。假设这里需要拆分列表 [1, 5, 0, 9, 2]，每次将其一分为二，直到每个子列表中仅剩 1 个元素：
![](https://img.weishidong.com/20210312220405.png)
> 下面介绍的代码示例与图示无关



用递归实现，只需要做 3 件事：


- [ ] 编写拆分操作的代码；
- [ ] 调用自身，调用时传递不同的值；
- [ ] 设定跳出条件，即所有子列表仅剩 1 个元素时结束递归；



刚接触递归算法的朋友会觉得递归很绕，难以掌握，实际上只需要按照上面列出的 3 个步骤编写，就不会出幺蛾子。基本的代码结构如下：
```python
def recursion():
    if:
        return
    return recursion()
```
第 2 行代码即设定跳出条件，第 3 行代码跳出递归，第 4 行代码则是递归的重要组成部分——函数调用自身。


## 递归算法实现


这里用阶乘的实现来作为递归的代码讲解，由于阶乘出现在九年义务教育中，且其思路清晰易于理解，是递归示例的不二之选。阶乘的数学表示为 n! = 1 × 2 × 3 × … × n，如果用代码则可以表示可以写为 n! = (n-1)! × n，具体的 Python 代码实现如下：
```python
def recursion(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * recursion(n - 1)

source = 5
result = recursion(source)
print(result)
```
这是一个求 5 阶乘的示例，最后输出的值为 120，即 120 = 1 × 2 × 3 × 4 × 5。递归的过程如下：
```python
recursion(5)                      # 第 1 轮函数调用
5 * recursion(4)                  # 第 2 轮函数调用
5 * 4 * recursion(3)              # 第 3 轮函数调用
5 * 4 * (3 * recursion(2))        # 第 4 轮函数调用
5 * 4 * (3 * (2 * recursion(1)))  # 第 5 轮函数调用 
5 * 4 * (3 * (2 * 1))             # 第 5 轮函数返回 
5 * 4 * (3 * 2)                   # 第 4 轮函数返回
5 * 4 * 6                         # 第 3 轮函数返回
5 * 24                            # 第 2 轮函数返回
120                               # 第 1 轮函数返回
```
从递归过程中可知，递归中函数的调用层层嵌套，但返回结果时则按后进先出的顺序返回，这点要记住。


递归的过程是调用时入栈，调用完毕后按后进先出方式返回



---

递归算法的计算其实是很耗费时间和资源的，因为里面包含大量的重复计算。优化的方式通常有 2 种，尾递归和缓存优化。目前本书暂未编写尾递归示例和实现，缓存优化详见本书（《Python 编程参考》）的**无限级分类树状结构生成算法。**

<Vssue :title="$title" />
